# Architecture checks
message("üèóÔ∏è Running architecture validation...")

# Check for architecture violations in changed files
git.modified_files.select { |f| f.end_with?(".kt") }.each do |file|
  content = File.read(file)

  # Check domain layer purity
  if file.include?("/domain/") && content.match?(/import\s+(android\.|androidx\.)/)
    fail("‚ùå Domain layer violation in `#{file}`: Domain cannot depend on Android framework")
  end

  # Check use case naming
  if file.include?("/usecase/") && !File.basename(file, ".kt").end_with?("UseCase")
    warn("‚ö†Ô∏è Use case naming violation: `#{file}` should end with 'UseCase'")
  end

  # Check repository interface placement
  if content.match?(/interface\s+\w*Repository/) && !file.include?("/domain/repository/")
    fail("‚ùå Repository interface in `#{file}` should be in domain/repository package")
  end

  # Check ViewModel dependencies
  if content.match?(/class\s+\w*ViewModel/) && content.match?(/import\s+.*\.data\./)
    warn("‚ö†Ô∏è ViewModel in `#{file}` should not directly depend on data layer")
  end
end

# Module dependency checks
git.modified_files.select { |f| f.end_with?(".kt") }.each do |file|
  content = File.read(file)

  # Check for cross-feature dependencies
  if file.match?(%r{feature/(\w+)})
    feature = $1
    if content.match?(%r{import.*\.feature\.(?!#{feature})\w+})
      fail("‚ùå Cross-feature dependency detected in `#{file}`: Features should be independent")
    end
  end

  # Check core modules don't depend on features
  if file.include?("/core/") && content.match?(/import.*\.feature\./)
    fail("‚ùå Core module dependency violation in `#{file}`: Core should not depend on features")
  end

  # Check data modules don't depend on features
  if file.include?("/data/") && content.match?(/import.*\.feature\./)
    fail("‚ùå Data module dependency violation in `#{file}`: Data should not depend on features")
  end
end

# PR size check
if git.lines_of_code > 500
  warn("‚ö†Ô∏è Large PR: #{git.lines_of_code} lines changed. Consider breaking it down.")
end

# Check for tests
has_tests = git.modified_files.any? { |f| f.include?("Test") }
has_source = git.modified_files.any? { |f| f.end_with?(".kt") && !f.include?("Test") }

if has_source && !has_tests
  warn("‚ö†Ô∏è No tests added for new code. Please add tests.")
end

# Check for new dependencies
build_files = git.modified_files.select { |f| f.include?("build.gradle") || f.include?("libs.versions.toml") }
if !build_files.empty?
  message("üì¶ Dependencies modified. Please ensure they follow architecture guidelines.")
end

# Architecture documentation check
if git.modified_files.any? { |f| f.include?("/domain/") || f.include?("/data/") }
  unless git.modified_files.any? { |f| f.include?("README") || f.include?("ARCHITECTURE") }
    message("üìù Consider updating architecture documentation for these changes")
  end
end

# Check for TODO/FIXME comments in new code
git.added_files.select { |f| f.end_with?(".kt") }.each do |file|
  content = File.read(file)
  if content.match?(/TODO|FIXME|HACK/)
    warn("‚ö†Ô∏è TODO/FIXME/HACK found in new file `#{file}`. Please resolve before merging.")
  end
end

# Check for hardcoded strings that should be in resources
git.modified_files.select { |f| f.end_with?(".kt") && f.include?("/presentation/") }.each do |file|
  content = File.read(file)
  hardcoded_strings = content.scan(/"[^"]{20,}"/).length
  if hardcoded_strings > 0
    warn("‚ö†Ô∏è Possible hardcoded strings in `#{file}`. Consider using string resources.")
  end
end

# Success message
if status_report[:errors].empty? && status_report[:warnings].empty?
  message("‚úÖ All architecture checks passed!")
end