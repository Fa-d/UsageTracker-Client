package dev.sadakat.screentimetracker.core.data.mapper

import dev.sadakat.screentimetracker.core.domain.model.*
import dev.sadakat.screentimetracker.core.data.local.dto.AppSessionDataAggregate
import dev.sadakat.screentimetracker.core.data.local.entities.*

// REMOVED: import dev.sadakat.screentimetracker.core.data.local.dto.AppSessionDataAggregate

// Type aliases to resolve ambiguity
typealias DomainWellnessScore = dev.sadakat.screentimetracker.core.domain.model.WellnessScore
typealias EntityWellnessScore = dev.sadakat.screentimetracker.core.data.local.entities.WellnessScore
typealias DomainAppCategory = dev.sadakat.screentimetracker.core.domain.model.AppCategory
typealias EntityAppCategory = dev.sadakat.screentimetracker.core.data.local.entities.AppCategory

/**
 * Bidirectional mapper between domain models and data entities for screen time tracking.
 * This maintains clean separation between layers while enabling data persistence.
 */
class ScreenTimeDataMapper {

    // ==================== Domain to Data Entity Mapping ====================

    fun mapToAppSessionEntity(appSession: AppSession): AppSessionEvent {
        return AppSessionEvent(
            id = 0, // Auto-generated by Room
            packageName = appSession.packageName,
            startTimeMillis = appSession.timeRange.startMillis,
            endTimeMillis = appSession.timeRange.endMillis,
            durationMillis = appSession.durationMillis
        )
    }

    fun mapToWellnessScoreEntity(wellnessScore: DomainWellnessScore): EntityWellnessScore {
        return EntityWellnessScore(
            date = wellnessScore.calculatedAt,
            totalScore = wellnessScore.overall,
            timeLimitScore = wellnessScore.screenTime,
            focusSessionScore = wellnessScore.goals,
            breaksScore = wellnessScore.unlocks,
            sleepHygieneScore = wellnessScore.consistency,
            level = mapToWellnessLevelString(wellnessScore.wellnessLevel),
            calculatedAt = wellnessScore.calculatedAt
        )
    }

    private fun mapToWellnessLevelString(level: WellnessLevel): String {
        return when (level) {
            WellnessLevel.DIGITAL_SPROUT -> "digital_sprout"
            WellnessLevel.MINDFUL_EXPLORER -> "mindful_explorer"
            WellnessLevel.BALANCED_USER -> "balanced_user"
            WellnessLevel.WELLNESS_MASTER -> "wellness_master"
        }
    }

    private fun mapFromWellnessLevelString(levelString: String): WellnessLevel {
        return when (levelString) {
            "digital_sprout" -> WellnessLevel.DIGITAL_SPROUT
            "mindful_explorer" -> WellnessLevel.MINDFUL_EXPLORER
            "balanced_user" -> WellnessLevel.BALANCED_USER
            "wellness_master" -> WellnessLevel.WELLNESS_MASTER
            else -> WellnessLevel.DIGITAL_SPROUT
        }
    }

    // ==================== Data Entity to Domain Model Mapping ====================

    fun mapToScreenTimeMetrics(
        sessions: List<AppSessionEvent>,
        unlocks: List<ScreenUnlockEvent>,
        wellnessScores: List<EntityWellnessScore>,
        appNames: Map<String, String> = emptyMap()
    ): ScreenTimeMetrics {
        val appSessions = sessions.map { mapToAppSession(it, appNames[it.packageName] ?: it.packageName) }
        val latestWellnessScore = wellnessScores.lastOrNull()?.let { mapToWellnessScore(it) }
            ?: DomainWellnessScore.default()

        return ScreenTimeMetrics(
            totalScreenTimeMillis = sessions.sumOf { it.durationMillis },
            unlockCount = unlocks.size,
            appSessions = appSessions,
            wellnessScore = latestWellnessScore
        )
    }

    fun mapToAppSession(sessionEvent: AppSessionEvent, appName: String = sessionEvent.packageName): AppSession {
        return AppSession(
            packageName = sessionEvent.packageName,
            appName = appName,
            timeRange = TimeRange(sessionEvent.startTimeMillis, sessionEvent.endTimeMillis),
            category = inferAppCategory(sessionEvent.packageName),
            sessionType = inferSessionType(sessionEvent.durationMillis)
        )
    }

    fun mapToWellnessScore(entity: EntityWellnessScore): DomainWellnessScore {
        return DomainWellnessScore(
            overall = entity.totalScore,
            screenTime = entity.timeLimitScore,
            unlocks = entity.breaksScore,
            goals = entity.focusSessionScore,
            productivity = 50, // Default value, would need separate tracking
            consistency = entity.sleepHygieneScore,
            calculatedAt = entity.calculatedAt,
            breaksScore = entity.breaksScore,
            focusSessionScore = entity.focusSessionScore,
            timeLimitScore = entity.timeLimitScore,
            date = entity.date
        )
    }

    // ==================== Aggregation Helpers ====================

    fun mapFromSessionAggregates(
        aggregates: List<AppSessionDataAggregate>,
        timeRange: TimeRange,
        appNames: Map<String, String> = emptyMap()
    ): List<AppSession> {
        return aggregates.flatMap { aggregate ->
            // Create representative sessions from aggregated data
            // This is a simplified mapping - in practice you might want to preserve actual session boundaries
            listOf(
                AppSession(
                    packageName = aggregate.packageName,
                    appName = appNames[aggregate.packageName] ?: aggregate.packageName,
                    timeRange = TimeRange(
                        startMillis = timeRange.startMillis,
                        endMillis = timeRange.startMillis + aggregate.totalDuration
                    ),
                    category = inferAppCategory(aggregate.packageName),
                    sessionType = SessionType.REGULAR
                )
            )
        }
    }

    fun mapToAppUsageSummary(
        aggregate: AppSessionDataAggregate,
        appName: String = aggregate.packageName
    ): dev.sadakat.screentimetracker.core.domain.repository.AppUsageSummary {
        return dev.sadakat.screentimetracker.core.domain.repository.AppUsageSummary(
            packageName = aggregate.packageName,
            appName = appName,
            totalTimeMillis = aggregate.totalDuration,
            sessionCount = aggregate.sessionCount,
            averageSessionTimeMillis = if (aggregate.sessionCount > 0) {
                aggregate.totalDuration / aggregate.sessionCount
            } else 0L,
            category = inferAppCategory(aggregate.packageName).name
        )
    }

    // ==================== Batch Mapping Functions ====================

    fun mapToAppSessionEntities(appSessions: List<AppSession>): List<AppSessionEvent> {
        return appSessions.map { mapToAppSessionEntity(it) }
    }

    fun mapToAppSessions(
        sessionEvents: List<AppSessionEvent>,
        appNames: Map<String, String> = emptyMap()
    ): List<AppSession> {
        return sessionEvents.map {
            mapToAppSession(it, appNames[it.packageName] ?: it.packageName)
        }
    }

    // ==================== Helper Functions ====================

    private fun inferAppCategory(packageName: String): DomainAppCategory {
        return when {
            packageName.contains("facebook") ||
            packageName.contains("instagram") ||
            packageName.contains("twitter") ||
            packageName.contains("tiktok") -> DomainAppCategory.SOCIAL_MEDIA

            packageName.contains("youtube") ||
            packageName.contains("netflix") ||
            packageName.contains("spotify") -> DomainAppCategory.ENTERTAINMENT

            packageName.contains("gmail") ||
            packageName.contains("whatsapp") ||
            packageName.contains("telegram") -> DomainAppCategory.COMMUNICATION

            packageName.contains("office") ||
            packageName.contains("docs") ||
            packageName.contains("notion") -> DomainAppCategory.PRODUCTIVITY

            packageName.contains("duolingo") ||
            packageName.contains("coursera") ||
            packageName.contains("udemy") -> DomainAppCategory.EDUCATION

            packageName.contains("game") ||
            packageName.contains("candy") ||
            packageName.contains("clash") -> DomainAppCategory.GAMES

            packageName.contains("health") ||
            packageName.contains("fitness") ||
            packageName.contains("nike") -> DomainAppCategory.HEALTH_FITNESS

            packageName.contains("amazon") ||
            packageName.contains("shop") ||
            packageName.contains("ebay") -> DomainAppCategory.SHOPPING

            packageName.contains("news") ||
            packageName.contains("reddit") ||
            packageName.contains("medium") -> DomainAppCategory.NEWS

            else -> DomainAppCategory.UNCATEGORIZED
        }
    }

    private fun inferSessionType(durationMillis: Long): SessionType {
        val focusThreshold = 25 * 60 * 1000L // 25 minutes
        return if (durationMillis >= focusThreshold) {
            SessionType.FOCUS_SESSION
        } else {
            SessionType.REGULAR
        }
    }

    // ==================== Validation Helpers ====================

    fun validateAppSession(appSession: AppSession): Boolean {
        return appSession.packageName.isNotBlank() &&
               appSession.appName.isNotBlank() &&
               appSession.timeRange.startMillis <= appSession.timeRange.endMillis &&
               appSession.durationMillis >= 0
    }

    fun validateWellnessScore(wellnessScore: DomainWellnessScore): Boolean {
        return wellnessScore.overall in 0..100 &&
               wellnessScore.screenTime in 0..100 &&
               wellnessScore.unlocks in 0..100 &&
               wellnessScore.goals in 0..100 &&
               wellnessScore.calculatedAt > 0
    }
}